#   Copyright 2017-2023 typed_python Authors
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

import unittest
from typed_python import Entrypoint, ListOf, TupleOf


class TestMasqueradeTypes(unittest.TestCase):
    """Test 'masquerade' types, which are often generated by *args and **kwargs.

    Masquerade types model anything where we are holding a data-structure that
    looks like a regular pythong type (say, a 'tuple') but is in fact held as
    a strongly-typed data structure (say, a TupleOf(int)). This happens when we
    have *args and **kwargs, since we use Tuple and NamedTuple to model the arguments
    passed to a function, but they need to look and feel like regular python objects.

    We also produce masquerades when you write inline lists, tuples, sets, dicts,
    etc.

    This presents a bit of a problem because mutable objects like 'dict' (produced
    for **kwargs) can't actually maintain type information. For now, we assume you're
    not directly modifying the kwargs you're passed in compiled code, and we don't
    allow list and dict masquerades to escape a given statement.
    """
    def test_compile_star_arg_of_masquerade(self):
        @Entrypoint
        def f(**x):
            return x['z']

        @Entrypoint
        def g(x: int):
            return f(z=(x, x))

        assert g(3) == (3, 3)

    def test_star_args_of_masquerade(self):
        def f(*args):
            return args[1]

        @Entrypoint
        def callF():
            return f(1, "a b c".split())

        self.assertEqual(callF.resultTypeFor().interpreterTypeRepresentation, list)

    def test_iterate_kwargs(self):
        def f(**kwargs):
            res = 0

            for name, value in kwargs.items():
                res += len(value)

            return res

        @Entrypoint
        def sumSomeThings():
            return f(x=TupleOf(int)([1, 2, 3]), y=ListOf(float)([1, 2, 3]))

        assert sumSomeThings() == 6

    def test_promote_masquerade_tuple_to_typed_tuple(self):
        @Entrypoint
        def f(x: TupleOf(int)):
            return len(x)

        @Entrypoint
        def callF():
            return f((1, 2, 3))

        assert callF() == 3

    def test_promote_masquerade_list_to_typed_list(self):
        @Entrypoint
        def f(x: ListOf(int)):
            return len(x)

        @Entrypoint
        def callF():
            return f([1, 2, 3])

        assert callF() == 3
